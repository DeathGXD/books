在前一个章节，我们对HBase给出了一个简单的介绍，但是现在我们将会深入HBase的细节看看HBase的基本原理和内部结构。尽管理解HBase原理对创造出一个好的设计非常重要，但是也不是强制的知道所有内部的细节。在本章，我们将关注HBase内部结构的讨论，这样会将你引向一个好的HBase表结构设计者。  

### 表的格式  
与传统的数据库相同的是，HBase将数据存储在表中并且也有行健和列名的概念。与传统数据库不同的是，HBase引进了列镞的概念，我们后面会介绍。相比于RDBMS，当命名相同时，表和列在HBase中不能够以相同的方式工作。如果你习惯于传统的RDBMS，大多数看起来都是非常相似的，但是由于这种方式的实现，当你在学习HBase时，你需要搁置你传统数据库的知识，并且抛弃你的偏见。  

在HBase中，你将会发现两种不同类型的表：系统表和用户表。系统表是被HBase内部使用用来跟踪像表的访问控制列表(ACLs)、表的元数据、region的元数据、命名空间等等的元信息。当然对你来说没有必要查看那些表。用户表就是为你的案例创建的表。它们默认属于default命名空间，除非你创建一个特有的命名空间并使用它。  

#### 表的布局  
HBase表是由一个或者多个列镞组成的(column family，又叫CF)，列族又包含一个或者多个存储值的列(column，我们称之为列限定符，简称CQ)。不像传统的数据库，HBase的表可能会是稀疏存储——一些列可能没有包含任何值。  





####　表的存储  
关于HBase表存储有几个方面。第一个方面是HBase如何存储一个单独的value到表中。第二个方面是关于那些单元格(cell)在文件中如何存储在一起并且构成一张表。  

正如图2-2所看到的，从顶部到底部，表由一个甚至多个region组成，而每个region都由一个甚至多个列族(column family)组成，而每个列族都由一个单独的store组成，而每个store都由唯一的memstore和一个甚至多个HFile组成，而每个HFile都由多个block组成，而每个block都由多个cell组成。  

在一个RegionServer上，一张表将会存在region个数乘以列族(column family)个数的memstores用来接受写请求，所有的操作将共享相同的保留的内存区域。  
![image](/Images/HBase/hbase-storage-layers.png)  
图2-2 存储布局  

在下面的子章节中将会对所有层次提供一个快速的认识。  

##### Region  
所有的行和相关列在一起构成HBase表。但是为了提供可扩展性，可伸缩性和快速的随机访问，HBase不得不将数据分布到多台服务器上。为了实现这一目标，HBase将表分裂成多个region，每个region都存储特定范围内的数据。Region被分配到多个专门为region服务的RegionServer上。在配置负载均衡之后，当创建了一个新的region时，HBase的负载均衡机制可能将新的region移动到其他RegionServer上，以确保集群上的负载是均匀分布的。类似预裂法，在region上有很多好的实践。所有的这些知识点将会在接下来的章节中提及。  

每个region都会有一个start key和一个end key来定义它的界限。所有的这些信息都会存储在region内部的文件中，但是也同样会存储在hbase:meta表中(或者是.META.表，对于HBase 0.96之前的版本)，一个记录所有region信息的表。当region变的很大，它将被切分。如果需要，它们也可以被合并。  

##### Column family  
列族是HBase中特有的概念，在其他RDBMS数据库中是找不到的。对于相同的region，不同的列族将会存储数据到不同文件中，并且配置也可以不同。拥有相同访问模式和格式的数据将会被分到相同的列族中。举个关于格式的例子，如果你需要存储大量客户档案的文本信息，除此之外还有每个客户的照片，因此你可能想要将他们存储到两个不同的列族中：一种被压缩的(所有文本信息将会被存储)，一种不被压缩的(所有图片将会被存储)。举个访问模式的例子：如果一些信息是主要是被读取并且几乎不会写入，一些信息主要是被写入并且几乎不会被读取，这时，你可能希望讲它们分到不同列族中。如果你想要存储一些类似格式和访问模式的数据到不同的列中，你应该将这些列分配到相同的列族中。  

RegionServer上的写缓存内存区域是被同一个主机上的所有region上的列族所共享。滥用列族将会给memstore增加压力，将会生成很多小文件，反过来将会产生大量的压缩可能对性能产生影响。无法对一张表进行配置来科学的限制列族的数量。然而，在最近的三年，大部分使用案例中我们有机会只需要使用一个列族。当然有一些需要两个列族，但是每次我们都发现多于两个列族，这样的话有可能甚至建议减少列族的数量来提高效率。如果你的设计中超过了三个列族，你可能需要深入的去看看是否那些列族都是必须的，最有可能的是，它们可以被重新分配。如果在两个列族中你没有任何一致性的限制并且数据进入表中的时间也不同，这样你可以创建两张表，每张表一个列族，进而取代在一张表中创建两个列族的设计。当决定region大小的时候，你会发现这一策略是非常有用的。的确，有时候让两个列族保持几乎相同的大小时，而现在通过将列族分开到不同的表中可以更加容易并且独立的增长。  

第15章将会提供更多关于列族的细节。  

##### Store  
我们将会发现每个列族对应着一个store。每个store又由一个memstore和零个或者多个store file(又叫做HFile)组成。store是HBase表存储所有信息的实体，同时也是读取数据的实体。  


##### HFile  
当memstore被写满必须被刷到磁盘的时候HFile会被创建。随着时间的推移，HFile最终会被合并到比较大的文件中(StoreFile)。它们(StoreFile)是存储store数据的格式。HFile由不同类型block组成(比如index block和data block)。HFile存储在HDFS上，因此，它们得益于Hadoop的持久性和备份机制。  


##### Block  
HFile是由block组成的。不要将HFile中的block和HDFS中的block混为一谈。一个HDFS的block可能包含多个HFile的block。HFile的block通常在8KB到1MB之间，但是默认的大小是64KB。可是，如果一个表被配置了压缩功能，HBase仍然会生成64KB的block，但是会压缩block。被压缩的block的在磁盘上的大小根据数据和压缩格式的不同可能会变化。较大的block将会创建较少的索引，有利于对表的连续访问；然而较小的block将会创建较多的索引，有利于对表的随机访问。  

**警告**：如果你将block的大小配置的很小，它将会创建很多HFile block索引，最后将会给内存相当大的压力，并且可能会产生相反的效果。同样，因为数据将会被压缩，压缩比总是更小，数据的大小将会增长。你需要将所有的这些细节都记在脑子里，以便于决定修改默认值使用。在做出决定性的配置修改之前，你应该使用不同的配置运行一些负载测试。然而，通常情况下，建议使用默认值。  

在HFile中主要会遇见下面几种block(因为它们是内部主要的细节实现，我们将只提供一个高层次的描述；如果你想了解详细的block类型，请参考HBase源代码)：  

**Data block**  
数据block包含的数据要么是压缩的，要么不是压缩，但不可能是二者的组合。数据block包含删除标记，而且包含put的数据。  

**Index block**  
当要查看特定的行，HBase通过索引block快速的在HFile中定位正确的位置。  

**Bloom filter block**  
这些block被用于存储布隆过滤器索引相关的信息。当查找特定的key时，布隆过滤器block被用于跳过文件的语法分析。  

**Trailer block**  
这种block包含HFile中其他大小可变的部分的偏移量。它也包含HFile的版本信息。  

Block是按照倒叙的方式存储的。这个意味着取代索引block存储在文件的开始，其他block跟在索引block之后的方式，block将被以倒序方式写入。数据block将第一个被存储，然后是索引block，再是布隆过滤器block；最后尾部block将存储在最后。  


##### Cell
HBase是面向列的数据库。那意味着HBase每个列将被单独的存储，而不是存储整个行本身。因为那些值可能会在不同的时间被插入，也可能在不同的HDFS文件中结束。  

图2-3代表了图2-1中HBase是如何存储值的。  
![image](/Images/HBase/hbase-table-physical-representation.png)  
图2-3 HBase表的物理表示  

正如你所看见的，仅仅有值的列会被存储，所有没有值的列都会被忽略。  

在内部，每个row存储的时候都会带有特定的格式，图2-4表示了一个独立的HBase cell的格式。  
![image](/Images/HBase/hbase-cell-format.png)  
图2-4：一个单独的HBase cell的格式  
